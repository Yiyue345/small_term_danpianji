C51 COMPILER V9.56.0.0   DS1302                                                            07/13/2025 23:25:48 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE DS1302
OBJECT MODULE PLACED IN ds1302.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ds1302.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "reg52.h"
   2          #include "ds1302.h"
   3          
   4          unsigned char code READ_RTC_ADDR[7] = {0x81, 0x83, 0x85, 0x87, 0x89, 0x8b, 0x8d}; // RTCè¯»åœ°å€
   5          unsigned char code WRITE_RTC_ADDR[7] = {0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c}; // RTCå†™åœ°å€
   6          // ä¿®æ”¹é»˜è®¤æ—¶é—´ä¸ºBCDæ ¼å¼ï¼š23æ—¶59åˆ†55ç§’ï¼Œ07æ—¥ï¼Œ07æœˆï¼Œ21å¹´ï¼Œæ˜ŸæœŸ6
   7          unsigned char TIME[7] = {0x55, 0x59, 0x23, 0x07, 0x07, 0x06, 0x21}; // ç§’ï¼Œåˆ†ï¼Œæ—¶ï¼Œæ—¥ï¼Œæœˆï¼Œå¹´ï¼
             -Œæ˜ŸæœŸ
   8          unsigned char cur_time_buf[7]; // å­˜å‚¨è½¬æ¢åçš„åè¿›åˆ¶æ—¶é—´
   9          
  10          // DS1302åº•å±‚é€šä¿¡å‡½æ•°
  11          void Ds1302_Write_Byte(unsigned char addr, unsigned char dat) {
  12   1          unsigned char i;
  13   1          
  14   1          RST_SET; // å¯åŠ¨ä¼ è¾“
  15   1      
  16   1          for (i = 0; i < 8; i++) {
  17   2              DS1302_DAT = addr & (0x01 << i);
  18   2              SCK_SET;
  19   2              SCK_CLR;
  20   2          }
  21   1      
  22   1          for (i = 0; i < 8; i++) {
  23   2              DS1302_DAT = dat & (0x01 << i);
  24   2              SCK_SET;
  25   2              SCK_CLR;
  26   2          }
  27   1      
  28   1          RST_CLR; // ç»“æŸä¼ è¾“
  29   1      
  30   1          // DS1302_DAT = addr & 0x01; // è®¾ç½®æ•°æ®çº¿ä¸ºåœ°å€æœ€ä½ä½
  31   1          
  32   1          // SCK_SET;
  33   1          // SCK_CLR;
  34   1      
  35   1          // å‘é€åœ°å€å­—èŠ‚
  36   1          // for (i = 0; i < 8; i++) {
  37   1          //     SCK_CLR;
  38   1          //     if (addr & 0x01) {
  39   1          //         DAT_SET;
  40   1          //     } else {
  41   1          //         DAT_CLR;
  42   1          //     }
  43   1          //     addr >>= 1;
  44   1          //     SCK_SET;
  45   1          // }
  46   1          
  47   1          // // å‘é€æ•°æ®å­—èŠ‚
  48   1          // for (i = 0; i < 8; i++) {
  49   1          //     SCK_CLR;
  50   1          //     if (dat & 0x01) {
  51   1          //         DAT_SET;
  52   1          //     } else {
  53   1          //         DAT_CLR;
  54   1          //     }
C51 COMPILER V9.56.0.0   DS1302                                                            07/13/2025 23:25:48 PAGE 2   

  55   1          //     dat >>= 1;
  56   1          //     SCK_SET;
  57   1          // }
  58   1          
  59   1      }
  60          // 111
  61          unsigned char Ds1302_Read_Byte(unsigned char addr) {
  62   1          unsigned char i, dat = 0x00;
  63   1          RST_CLR; // å¤ä½DS1302
  64   1          SCK_CLR;
  65   1      
  66   1          RST_SET; // å¯åŠ¨ä¼ è¾“
  67   1          for (i = 0; i < 8; i++) {
  68   2              DS1302_DAT = addr & (0x01 << i);
  69   2              SCK_SET;
  70   2              SCK_CLR;
  71   2          }
  72   1         
  73   1          for (i = 0; i < 8; i++) {
  74   2              
  75   2              if (DS1302_DAT) {
  76   3                  dat |= (0x01 << i);
  77   3              }
  78   2              SCK_SET;
  79   2              SCK_CLR; 
  80   2      
  81   2         }
  82   1          DAT_CLR;
  83   1          RST_CLR;
  84   1          return dat;
  85   1          
  86   1          // // å‘é€åœ°å€å­—èŠ‚
  87   1          // for (i = 0; i < 8; i++) {
  88   1          //     SCK_CLR;
  89   1          //     if (addr & 0x01) {
  90   1          //         DAT_SET;
  91   1          //     } else {
  92   1          //         DAT_CLR;
  93   1          //     }
  94   1          //     addr >>= 1;
  95   1          //     SCK_SET;
  96   1          // }
  97   1          
  98   1          // // è¯»å–æ•°æ®å­—èŠ‚å‰ï¼Œéœ€è¦å°†æ•°æ®çº¿è®¾ç½®ä¸ºè¾“å…¥
  99   1          // // è¯»å–æ•°æ®å­—èŠ‚
 100   1          // for (i = 0; i < 8; i++) {
 101   1          //     SCK_CLR;
 102   1          //     SCK_SET;
 103   1          //     if (DS1302_DAT) {
 104   1          //         dat |= (0x01 << i);
 105   1          //     }
 106   1          // }
 107   1          
 108   1          // RST_CLR; // ç»“æŸä¼ è¾“
 109   1          // SCK_CLR; // ç¡®ä¿æ—¶é’Ÿçº¿ä¸ºä½
 110   1      
 111   1          
 112   1      }
 113          
 114          void Ds1302_Init(void) {
 115   1          RST_CLR;
 116   1          SCK_CLR;
C51 COMPILER V9.56.0.0   DS1302                                                            07/13/2025 23:25:48 PAGE 3   

 117   1      
 118   1          // é¦–å…ˆè§£é™¤å†™ä¿æŠ¤
 119   1          Ds1302_Write_Byte(0x8e, 0x00);
 120   1          // å¯åŠ¨æ—¶é’Ÿï¼ˆæ¸…é™¤ç§’å¯„å­˜å™¨çš„CHä½ï¼‰
 121   1          // Ds1302_Write_Byte(Ds1302_sec_add, 0x00);
 122   1          // é‡æ–°å¯ç”¨å†™ä¿æŠ¤
 123   1          Ds1302_Write_Byte(0x8e, 0x80);
 124   1      }
 125          
 126          void Ds1302_Init_Time(void) {
 127   1          unsigned char i;
 128   1          
 129   1          Ds1302_Write_Byte(0x8e, 0x00); // ç¦æ­¢å†™ä¿æŠ¤
 130   1          for (i = 0; i < 7; i++) {
 131   2              Ds1302_Write_Byte(WRITE_RTC_ADDR[i], TIME[i]);
 132   2          }
 133   1          Ds1302_Write_Byte(0x8e, 0x80); // å…è®¸å†™ä¿æŠ¤
 134   1          
 135   1      }
 136          
 137          void Ds1302_Write_Time(void) {
 138   1          unsigned char i;
 139   1          
 140   1          Ds1302_Write_Byte(0x8e, 0x00); // ç¦æ­¢å†™ä¿æŠ¤
 141   1          for (i = 0; i < 7; i++) {
 142   2              Ds1302_Write_Byte(WRITE_RTC_ADDR[i], cur_time_buf[i]);
 143   2          }
 144   1          Ds1302_Write_Byte(0x8e, 0x80); // å…è®¸å†™ä¿æŠ¤
 145   1          
 146   1      }
 147          
 148          void Ds1302_Read_Time(void) {
 149   1          unsigned char i, temp;
 150   1          
 151   1          for (i = 0; i < 7; i++) {
 152   2              TIME[i] = Ds1302_Read_Byte(READ_RTC_ADDR[i]);
 153   2          }
 154   1      
 155   1          for (i = 0; i < 7; i++) {
 156   2              temp = TIME[i] / 16;
 157   2              cur_time_buf[i] = TIME[i] % 16;
 158   2              cur_time_buf[i] += temp * 10; // è½¬æ¢BCDç 
 159   2          }
 160   1      }
 161          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    301    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
